---

# purescript

> I started PureScript because the language I wanted on the front end didn't exist, and that's still why I work on it and use it. I want type classes, and functional dependencies, and higher kinded types, and rank N types, and various other things in my type system. And I want predictable code generation, and a minimal language and standard library. That combination just didn't exist when I started on PureScript.
> @paf31 
 
See Phil's article [Why you should use purescript?](http://blog.functorial.com/posts/2017-08-09-Why-You-Should-Use-PureScript.html) for some of the highlights

---

## a haskell programmer's solution to the javascript problem

- algebraic datatypes (sums of products), row types (records)
- type classes (functor, monad, foldable, etc) and constraints
- pure, extensible effects (may go away)
- prism/lens/traversals

```haskell
data MyProd = MyProd Int String

data MySum = MyInt Int 
           | MyString String

data MyRec1 = MyRec1 {name :: String, size :: Int}
data MyRec2 = MyRec2 {age :: Int, nice :: Boolean}

data MyRecProd = MyRecProd MyRec1 MyRec2

data MyRecSum  = FirstRec MyRec1 
               | SndRec MyRec2
```

---

## a haskell programmer's solution to the javascript problem

- compiles to clean (human readable) JS code
- easy FFI, use existing js libraries whenever makes sense
- doesn't yet optimize

---

## comparison with
- elm
*-* functional, row types
*-* arguably easier to get started 
*-* weaker type system (effects, polymorphism, typeclasses)

- ghcjs
 *-* make use of existing haskell ecosystem
 *-* laziness, garbage collection, shared code
 *-* heavy (needs runtime)
---
